<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[139. Word Break]]></title>
    <url>%2F2018%2F12%2F10%2F139-WordBreak%2F</url>
    <content type="text"><![CDATA[338. Counting BitsLeetcode Link Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. Example 1:12Input: 2Output: [0,1,1] Example 2:12Input: 5Output: [0,1,1,2,1,2] Example: SolutionIdea It’s easy to come up with an O(n*sizeof(integer)) solution, we just need to use Integer.toBinaryString(num) to every value from 0 to num-1, then count the number of 1 A more efficient solution is to use dynamic programming. Now, instead of considering binary format, let’s think about decimal version: Imagine we want to know how many 1s in 101010, what we can do? We could use the number of 10101 + 0, that is numOfOne[101010/10] + numOfOne[101010%10] Then we could further get the number of 10101 by adding numOfOne[10101/10] + numOfOne[10101%10], so on so forth Now, if we know how to solve this problem with a decimal version, then for the binary version, we just need to change num/10 and num%10 to num/2 and num%2 Corner case DP[0] = 0 — initial state of this dp solution Code DP12345678910public int[] countBits(int num) &#123; if(num==0) return new int[]&#123;0&#125;; int[] res = new int[num+1]; res[0] = 0; res[1] = 1; for(int i=2;i&lt;res.length;i++)&#123; res[i] = res[i/2] + res[i%2]; &#125; return res;&#125;]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic programming</category>
        <category>Leetcode</category>
        <category>Backtracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
        <tag>Dynamic programming</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[338. Counting Bits]]></title>
    <url>%2F2018%2F12%2F10%2F338-CountingBits%2F</url>
    <content type="text"><![CDATA[338. Counting BitsLeetcode Link Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. Example 1:12Input: 2Output: [0,1,1] Example 2:12Input: 5Output: [0,1,1,2,1,2] Example: SolutionIdea It’s easy to come up with an O(n*sizeof(integer)) solution, we just need to use Integer.toBinaryString(num) to every value from 0 to num-1, then count the number of 1 A more efficient solution is to use dynamic programming. Now, instead of considering binary format, let’s think about decimal version: Imagine we want to know how many 1s in 101010, what we can do? We could use the number of 10101 + 0, that is numOfOne[101010/10] + numOfOne[101010%10] Then we could further get the number of 10101 by adding numOfOne[10101/10] + numOfOne[10101%10], so on so forth Now, if we know how to solve this problem with a decimal version, then for the binary version, we just need to change num/10 and num%10 to num/2 and num%2 Corner case DP[0] = 0 — initial state of this dp solution Code DP12345678910public int[] countBits(int num) &#123; if(num==0) return new int[]&#123;0&#125;; int[] res = new int[num+1]; res[0] = 0; res[1] = 1; for(int i=2;i&lt;res.length;i++)&#123; res[i] = res[i/2] + res[i%2]; &#125; return res;&#125;]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic programming</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Memory Management]]></title>
    <url>%2F2018%2F12%2F10%2FJavaMemoryManagManagement%2F</url>
    <content type="text"><![CDATA[JVM Understanding Chapter 1: Java Memory Management Special thanks to jamesdbloom’s blog linkAnother reference linkAnother reference for heap allocate policy Java virtual machine for Java SE 7 Edition is made up with the following components Tread independent components: Program Counter VM stack Native stack Shared components Between Threads: Heap Method Area Non-Heap Memory Explanation of each componentsProgram Counter (PC)Address of the current instruction (or opcode) unless it is native. If the current method is native then the PC is undefined. All CPUs have a PC, typically the PC is incremented after each instruction and therefore holds the address of the next instruction to be executed. The JVM uses the PC to keep track of where it is executing instructions, the PC will in fact be pointing at a memory address in the Method Area.当前线程所执行的字节码的行号指示器，用于完成分支、循环、跳转等操作，线程独立 StackEach thread has its own stack that holds a frame for each method executing on that thread. The stack is a Last In First Out (LIFO) data structure, so the currently executing method is at the top of the stack. A new frame is created and added (pushed) to the top of stack for every method invocation. The frame is removed (popped) when the method returns normally or if an uncaught exception is thrown during the method invocation. In the stack, there is a local variable array. The array of local variables contains all the variables used during the execution of the method, including a reference to this, all method parameters and other locally defined variables. For class methods (i.e. static methods) the method parameters start from zero, however, for instance method the zero slot is reserved for this. A local variable can be: boolean byte char long short int float double reference returnAddress Native StackNot all JVMs support native methods, however, those that do typically create a per thread native method stack. If a JVM has been implemented using a C-linkage model for Java Native Invocation (JNI) then the native stack will be a C stack. In this case the order of arguments and return value will be identical in the native stack to typical C program. A native method can typically (depending on the JVM implementation) call back into the JVM and invoke a Java method. Such a native to Java invocation will occur on the stack (normal Java stack); the thread will leave the native stack and create a new frame on the stack (normal Java stack). HeapThe Heap is used to allocate class instances and arrays at runtime. Arrays and objects can never be stored on the stack because a frame is not designed to change in size after it has been created. The frame only stores references that point to objects or arrays on the heap. Unlike primitive variables and references in the local variable array (in each frame) objects are always stored on the heap so they are not removed when a method ends. Instead objects are only removed by the garbage collector. To support garbage collection the heap is divided into three sections: Young Generation Often split between Eden and Survivor Old Generation (also called Tenured Generation) Permanent Generation Non-Heap MemoryObjects that are logically considered as part of the JVM mechanics are not created on the Heap. The non-heap memory includes: Permanent Generation that contains the method area interned strings Code Cache used for compilation and storage of methods that have been compiled to native code by the JIT compiler Method AreaThe method area stores per-class information such as: Classloader Reference Run Time Constant Pool Numeric constants Field references Method References Attributes Field data Per field Name Type Modifiers Attributes Method data Per method Name Return Type Parameter Types (in order) Modifiers Attributes Method code Per method Bytecodes Operand stack size Local variable size Local variable table Exception table Per exception handler Start point End point PC offset for handler code Constant pool index for exception class being caught]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100. Same Tree]]></title>
    <url>%2F2018%2F12%2F09%2F100-SameTree%2F</url>
    <content type="text"><![CDATA[100. Same TreeLeetcode Link Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1:1234567Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]Output: true Example 2:1234567Input: 1 1 / \ 2 2 [1,2], [1,null,2]Output: false Example 3:1234567Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]Output: false SolutionIdea An easy probe tree problem, just probe every node and check if the values are equal or null Corner case Tree is null Don’t forget to consider the following situation12345 2 2 / \ / \7 9 7 9 \ 10 12345 2 2 / \ / \ 7 9 7 9 / \10 10 Code DFS 12345678910111213141516171819202122public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p==null&amp;&amp;q==null) return true; if(p==null||q==null) return false; Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;(); stack1.push(p); Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;(); stack2.push(q); while(!stack1.isEmpty()&amp;&amp;!stack2.isEmpty())&#123; TreeNode node1 = stack1.pop(); TreeNode node2 = stack2.pop(); if(node1==null&amp;&amp;node2==null) continue; else if(node1==null||node2==null) return false; else&#123; if(node1.val!=node2.val) return false; stack1.push(node1.left); stack1.push(node1.right); stack2.push(node2.left); stack2.push(node2.right); &#125; &#125; return true;&#125; Recursion 123456public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p==null&amp;&amp;q==null) return true; if(p==null||q==null) return false; if(p.val==q.val) return isSameTree(p.left,q.left)&amp;&amp;isSameTree(p.right,q.right); else return false;&#125;]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[96. Unique Binary Search Trees]]></title>
    <url>%2F2018%2F12%2F09%2F96-UniqueBinarySearchTrees%2F</url>
    <content type="text"><![CDATA[96. Unique Binary Search TreesLeetcode Link Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n? Example: Input: 3Output: 5Explanation:Given n = 3, there are a total of 5 unique BST’s:123451 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \2 1 2 3 SolutionIdea At the first glance it might seem to a Tree related problem, but it’s actually a dynamic programming problem. Well, how can we come up with a solution? We first want to make sure that it’s not a tree related problem. We don’t even have a valid TreeNode input. All we know is just an input number and a BST tree structure. Em… It’s definitely no need to construct these trees by myself. when facing this situation, write down some specific examples are usually helpful. when n = 1 110 when n = 2 123456789 10 /5or5 \ 10 when n = 3 1234510 999 999 10 5 \ / / / \ \ 999 10 5 5 999 10 / / \ \5 5 10 999 we first could notice that these values are not important, they could be any value as long as the tree is a valid BST If we see further in detail we could notice that we do have some familiar schema in n = 3: That is we do have several following structure when n = 31235 10 \ / 10 5 That is, the schema of n=2 could be used to n = 3 Now, if we abstract 999 as X, we could have the following situations:12345X X X X X \ \ / \ / / 10 5 5 10 10 5 / \ / \5 10 5 10 123456 X X X / \ / \ / \ 0LN 2RN 1LN 1RN 2LN 0LNLN: left nodes. 0LN means 0 left nodesRN: right nodes. 2RN means 2 right nodes. At the 2RN or 2LN scenario, we already know that we have 2 possible result1235 10 \ / 10 5 At the 1RN or 1LN scenario, we already know that we have 1 possible resultThen what we need to do is add up all these together then we could get the answer of 3LN and 3RN. So on so forth until we get n nodes Corner case DP[0] = 1 — initial state of this dp solution Code DP12345678910111213public int numTrees(int n) &#123; if(n&lt;=0) return 0; int[] src = new int[n+1]; src[0] = 1; src[1] = 1; for(int i=2;i&lt;=n;i++)&#123; for(int j=0;j&lt;=i-1;j++)&#123; //src[2] = src[0]*src[1] + src[1]*src[0] src[i] += src[j]*src[i-j-1]; &#125; &#125; return src[n];&#125;]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Dynamic programming</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
        <tag>Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[173. Binary Search Tree Iterator]]></title>
    <url>%2F2018%2F12%2F09%2F173-BinarySearchTreeIterator%2F</url>
    <content type="text"><![CDATA[173. Binary Search Tree IteratorLink Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. SolutionIdea This is a typical problem of using pre-order traversal method to solve it. If it’s your first time hearing about pre-order traversal, I suggest you read this post Link first Basically we need to use a stack to save node’s values and do a pre-order traversal to the BST. At each next() operation, we pop out the smallest value and push the current smallest value into the stack again. There is a common schema to do a pre-order traversal, I will just write the code. Corner case Tree is null Code123456789101112131415161718192021222324252627282930public class BSTIterator &#123; private TreeNode root; private Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); public BSTIterator(TreeNode root) &#123; this.root = root; while(root!=null)&#123; stack.push(root); root = root.left; &#125; &#125; /** @return whether we have a next smallest number */ public boolean hasNext() &#123; return !stack.isEmpty(); &#125; /** @return the next smallest number */ public int next() &#123; TreeNode temNode = stack.pop(); int res = temNode.val; temNode = temNode.right; while(temNode!=null)&#123; stack.push(temNode); temNode = temNode.left; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[226. Invert Binary Tree]]></title>
    <url>%2F2018%2F12%2F09%2F226-InvertBinaryTree%2F</url>
    <content type="text"><![CDATA[226. Invert Binary TreeLink Invert a binary tree. Example: Input:12345 4 / \ 2 7 / \ / \1 3 6 9 Output:123456 4 / \ 7 2 / \ / \9 6 3 1 SolutionIdea Do you know how to swap 2 values? Well then we could use the same method to swap two nodes right? But only swap two nodes is not enough, we also need to swap these two nodes’ child nodes, so on so forth, until we swap all nodes. Therefore, a recursion method is easy to come up Solution 2 is using BFS. Since we know how to swap two nodes, then we just probe the tree level by level, then swap each node’s left child as right child. Corner case Tree is null Code Recursion O(N) 1234567public TreeNode invertTree(TreeNode root) &#123; if(root==null) return root; TreeNode temNode = root.left; root.left = invertTree(root.right); root.right = invertTree(temNode); return root;&#125; BFS O(N) 12345678910111213141516171819202122232425public TreeNode invertTree(TreeNode root) &#123; if(root==null) return null; LinkedList&lt;TreeNode&gt; quene = new LinkedList&lt;&gt;(); quene.offer(root); while(!quene.isEmpty())&#123; for(int i=quene.size();i&gt;0;i--)&#123; TreeNode tem = quene.poll(); TreeNode left = tem.left; if(tem.left!=null)&#123; quene.offer(tem.left); &#125; if(tem.right!=null)&#123; quene.offer(tem.right); &#125; tem.left = tem.right; tem.right = left; &#125; &#125; return root;&#125;]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[104. Maximum Depth of Binary Tree]]></title>
    <url>%2F2018%2F12%2F09%2F104_MaximumDepthofBinaryTree%2F</url>
    <content type="text"><![CDATA[104. Maximum Depth of Binary TreeLink Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example 1Given binary tree [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 return its depth = 3. SolutionIdea This is the most common tree probing problem, if you can’t come up with one solution in 5 seconds, then I suggest you first read this post Link first Corner case Tree is null Code BFS 12345678910111213141516171819202122public int maxDepth(TreeNode root) &#123; if(root==null) return 0; int res = 0; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; levels = new Stack&lt;&gt;(); levels.push(1); stack.push(root); while(!stack.isEmpty())&#123; int level = levels.pop(); res = Math.max(res, level); TreeNode node = stack.pop(); if(node.left!=null)&#123; stack.push(node.left); levels.push(level+1); &#125; if(node.right!=null)&#123; stack.push(node.right); levels.push(level+1); &#125; &#125; return res; &#125; DFS 12345678910111213141516public int maxDepth(TreeNode root)&#123; if(root==null) return 0; int res = 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; int size = queue.size(); res++; for(int i=0;i&lt;size;i++)&#123; TreeNode node = queue.poll(); if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); &#125; &#125; return res;&#125; Recursion 1234public int maxDepth(TreeNode root) &#123; if(root==null) return 0; return 1+ Math.max(maxDepth(root.left),maxDepth(root.right));&#125;]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode]]></title>
    <url>%2F2018%2F12%2F08%2FLeetcode%2F</url>
    <content type="text"><![CDATA[This is the general markdown layout of my Leetcode problem postsProblem namesLink problem description example 1balabalabalaaa example 2balabalabalaaa SolutionIdea balabalabalaaa sublist balabalabalaaa Corner case balabalabalaaa balabalabalaaa balabalabalaaa Code1234public static coid main()&#123; hello world Solution&#125;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The absolute guidance of Tree problems on leetcode]]></title>
    <url>%2F2018%2F12%2F08%2FTree%2F</url>
    <content type="text"><![CDATA[All common and frequently used data structure for Tree problemsKeeping updateTree structureA tree class will look like this:123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; A tree structure will look like this: Advanced Tree structureSome more advanced tree structure might have more than 2 children, like N-ary Tree, and the tree class will look like this12345public class TreeNode&#123; TreeNode root; List&lt;TreeNode&gt; children; int val;&#125; Question Genres:1.Probe TreeA probe tree question is a kind of question that you need to probe every node of the tree to get the answer. Data structure to solve it BFS (Breadth-first search)BFS is a way to search the tree level by level. In java, we use the Queue data structure. Queue is a FIFO data structure. In a FIFO data structure, the first element added to the queue will be the first one to be removed. Abstract code123456789101112131415161718public void probeTree(TreeNode root)&#123; if(root==null) return; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!root.isEmpty())&#123; int size = queue.size();//size remembers the number of nodes that locates at the current level for(int i=0;i&lt;size;i++)&#123; TreeNode node = queue.poll(); // some operations at here if(node.left!=null)&#123; queue.offer(node.left); &#125; if(node.right!=null)&#123; queue.offer(node.right); &#125; &#125; &#125;&#125; DFS (Depth-first search)DFS is a way to probe the whole tree from root to every leaf. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking. DFS is a LIFO data structure. In java we use Stack to do it. Abstract code123456789101112131415public void probeTree(TreeNode root)&#123; if(root==null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; TreeNode node = stack,pop(); //do some operations here if(node.left!=null)&#123; stack.push(node.left); &#125; if(node.right!=null)&#123; stack.push(node.right); &#125; &#125;&#125; RecursionRecursion is a way to probe the tree recursively using one method. For one node, we could treat it as the parent node of its children, and also as the child node of its parent. Hence this node is a parent node and a child node. Therefore, we could treat every node as the parent/root node, then do some operations on its child nodes. Abstract code123456public void probeTree(TreeNode root)&#123; if(root==null) return; //do some operations here probeTree(root.left); probeTree(root.right);&#125; Here are the list of all questions that based on probing a tree 104. Maximum Depth of Binary Tree -Easy 100. Same Tree -Easy 2. Re-organize Tree structureSome problems want you to re-organize the tree structure to meet its standard, such as flip left and right node or add another pointer to the tree. I usually try to find a recursion solution first, then try to solve it iteratively. Because most of time recursion is better for this kind of solution There is no common schema codes for this kind of question since each question may have specific requirement Here are the list of all questions that are related to re-organizing a tree 226. Invert Binary Tree -Easy 3. Pre-order, in-order and post-order traversalThis is a very very important topics and everyone should master it. If it is the first time for you to hear about this topic, then I suggest you watch this video Binary tree traversal: Preorder, Inorder, Postorder to get a quick understanding about order traversal methods.Example:For a tree looks like this: Preorder (Root, Left, Right) : 1 2 4 5 3Inorder (Left, Root, Right) : 4 2 5 1 3Postorder (Left, Right, Root) : 4 5 2 3 1 Characteristics of different order traversal methods Pre-orderPre-order traversal always visit the left node first, then root, then right node. And we all know that for a binary search tree, left node &lt; root &lt; right node. Therefore, if you do a pre-order traversal for BST, we could generate a sorted list of all values saved in this BST. Code schema for probing a tree with pre-order traversalIn java, we use a stack to save node’s values. we first use a loop to reach to the left-most node, then each time we pop out a new node, we reach to the new node’s left-most node again12345678910111213141516public void inOrderTraversal(TreeNode root)&#123; Stack&lt;TreeNode&gt; stack = new TreeNode&lt;&gt;(); while(root!=null)&#123; stack.push(root); root = root.left; &#125; while(!stack.isEmpty())&#123; TreeNode node = stack.pop(); //do some operations Here node = node.right; while(node!=null)&#123; stack.push(node); node = node.left; &#125; &#125;&#125; In-order Post-order Here are the list of all questions that are related to re-organizing a tree]]></content>
      <categories>
        <category>Leetcode</category>
        <category>LeetcodeReview</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
</search>
