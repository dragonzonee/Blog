<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[226_InvertBinaryTree]]></title>
    <url>%2F2018%2F12%2F09%2F226-InvertBinaryTree%2F</url>
    <content type="text"><![CDATA[226. Invert Binary TreeLink Invert a binary tree. Example: Input:12345 4 / \ 2 7 / \ / \1 3 6 9 Output:123456 4 / \ 7 2 / \ / \9 6 3 1 SolutionIdea Do you know how to swap 2 values? Well then we could use the same method to swap two nodes right? But only swap two nodes is not enough, we also need to swap these two nodes’ child nodes, so on so forth, until we swap all nodes. Therefore, a recursion method is easy to come up Solution 2 is using BFS. Since we know how to swap two nodes, then we just probe the tree level by level, then swap each node’s left child as right child. Corner case Tree is null Code Recursion O(N) 1234567public TreeNode invertTree(TreeNode root) &#123; if(root==null) return root; TreeNode temNode = root.left; root.left = invertTree(root.right); root.right = invertTree(temNode); return root;&#125; BFS O(N) 12345678910111213141516171819202122232425public TreeNode invertTree(TreeNode root) &#123; if(root==null) return null; LinkedList&lt;TreeNode&gt; quene = new LinkedList&lt;&gt;(); quene.offer(root); while(!quene.isEmpty())&#123; for(int i=quene.size();i&gt;0;i--)&#123; TreeNode tem = quene.poll(); TreeNode left = tem.left; if(tem.left!=null)&#123; quene.offer(tem.left); &#125; if(tem.right!=null)&#123; quene.offer(tem.right); &#125; tem.left = tem.right; tem.right = left; &#125; &#125; return root;&#125;]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[104. Maximum Depth of Binary Tree]]></title>
    <url>%2F2018%2F12%2F09%2F104_MaximumDepthofBinaryTree%2F</url>
    <content type="text"><![CDATA[104. Maximum Depth of Binary TreeLink Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example 1Given binary tree [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 return its depth = 3. SolutionIdea This is the most common tree probing problem, if you can’t come up with one solution in 5 seconds, then I suggest you first read this post Link first Corner case Tree is null Code BFS 12345678910111213141516171819202122public int maxDepth(TreeNode root) &#123; if(root==null) return 0; int res = 0; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; levels = new Stack&lt;&gt;(); levels.push(1); stack.push(root); while(!stack.isEmpty())&#123; int level = levels.pop(); res = Math.max(res, level); TreeNode node = stack.pop(); if(node.left!=null)&#123; stack.push(node.left); levels.push(level+1); &#125; if(node.right!=null)&#123; stack.push(node.right); levels.push(level+1); &#125; &#125; return res; &#125; DFS 12345678910111213141516public int maxDepth(TreeNode root)&#123; if(root==null) return 0; int res = 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; int size = queue.size(); res++; for(int i=0;i&lt;size;i++)&#123; TreeNode node = queue.poll(); if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); &#125; &#125; return res;&#125; Recursion 1234public int maxDepth(TreeNode root) &#123; if(root==null) return 0; return 1+ Math.max(maxDepth(root.left),maxDepth(root.right));&#125;]]></content>
      <categories>
        <category>Leetcode</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode]]></title>
    <url>%2F2018%2F12%2F08%2FLeetcode%2F</url>
    <content type="text"><![CDATA[This is the general markdown layout of my Leetcode problem postsProblem namesLink problem description example 1balabalabalaaa example 2balabalabalaaa SolutionIdea balabalabalaaa sublist balabalabalaaa Corner case balabalabalaaa balabalabalaaa balabalabalaaa Code1234public static coid main()&#123; hello world Solution&#125;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The absolute guidance of Tree problems on leetcode]]></title>
    <url>%2F2018%2F12%2F08%2FTree%2F</url>
    <content type="text"><![CDATA[All common and frequently used data structure for Tree problemsTree structureA tree class will look like this:123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; A tree structure will look like this: Advanced Tree structureSome more advanced tree structure might have more than 2 children, like N-ary Tree, and the tree class will look like this12345public class TreeNode&#123; TreeNode root; List&lt;TreeNode&gt; children; int val;&#125; Question Genres:1.Probe TreeA probe tree question is a kind of question that you need to probe every node of the tree to get the answer. Data structure to solve it BFS (Breadth-first search)BFS is a way to search the tree level by level. In java, we use the Queue data structure. Queue is a FIFO data structure. In a FIFO data structure, the first element added to the queue will be the first one to be removed. Abstract code123456789101112131415161718public void probeTree(TreeNode root)&#123; if(root==null) return; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!root.isEmpty())&#123; int size = queue.size();//size remembers the number of nodes that locates at the current level for(int i=0;i&lt;size;i++)&#123; TreeNode node = queue.poll(); // some operations at here if(node.left!=null)&#123; queue.offer(node.left); &#125; if(node.right!=null)&#123; queue.offer(node.right); &#125; &#125; &#125;&#125; DFS (Depth-first search)DFS is a way to probe the whole tree from root to every leaf. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking. DFS is a FILO data structure. In java we use Stack to do it. Abstract code123456789101112131415public void probeTree(TreeNode root)&#123; if(root==null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; TreeNode node = stack,pop(); //do some operations here if(node.left!=null)&#123; stack.push(node.left); &#125; if(node.right!=null)&#123; stack.push(node.right); &#125; &#125;&#125; RecursionRecursion is a way to probe the tree recursively using one method. For one node, we could treat it as the parent node of its children, and also as the child node of its parent. Hence this node is a parent node and a child node. Therefore, we could treat every node as the parent/root node, then do some operations on its child nodes. Abstract code123456public void probeTree(TreeNode root)&#123; if(root==null) return; //do some operations here probeTree(root.left); probeTree(root.right);&#125; Here are the list of all questions that based on probing a tree 104. Maximum Depth of Binary Tree -Easy 2. Re-organize Tree structureSome problems want you to re-organize the tree structure to meet its standard, such as flip left and right node or add another pointer to the tree. I usually try to find a recursion solution first, then try to solve it iteratively. Because most of time recursion is better for this kind of solution There is no common schema codes for this kind of question since each question may have specific requirement Here are the list of all questions that are related to re-organizing a tree 226. Invert Binary Tree -Easy]]></content>
      <categories>
        <category>Leetcode</category>
        <category>LeetcodeReview,</category>
        <category>Tree</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithms</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
</search>
